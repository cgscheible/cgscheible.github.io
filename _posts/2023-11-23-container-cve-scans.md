## A scalable approach to Container Image Vulnerability Scanning

Container base and application images are the packaging artifacts for container workloads and contain application and all software dependencies. This means that there are tens if not hundreds of binaries and libraries in container images and should be carefully managed. In my view, the right approach for this is a clearly defined container image lifecycle with frequent and automated pipeline builds as well as sensible image policies on security vulnerabilties as well as image aging.
###Small Container Images
Reduce the attack surface and improve build and run performance by using lightweight container base images
###Image Aging and Expiration Policy
Container images need this for operational and security hygiene. 

* Image sprawl: Container registry storage is ever-growing when images are retained for long periods or even worse undefined, i.e. forever.
* Image security: The older a container image the more likely it is to contain unpatched vulnerabilities.

An image expiration policy can contain several rules that can be automated and fulfil the operational and secruity objectives:

* Automated removal of obsolete container images based on last-access metadata. If e.g. a container image is not downloaded from the container registry within the last 90 days, an auto-delete policy would remove the image.

* Automated removal of old builds, i.e. container images that are considered obsolete due to newer image releases. E.g. retain only the last 5 releases of any container image in the registry. 
 
* Quarantine: Registry download of container images that contain high and critical vulnerabilities should be automatically blocked. 

###Key factors for image lifecycle

* Frequent, automated builds and image updates in the container registry

* Automated software inventory and security scans as stage in the image build pipeline

* Image signing as guardrail for the container registry to only accept images originating from the container CI/CD pipeline

* Image tagging release control: 'latest' tag permitted for development environments, higher envs require unmutable image tags and signed images.

* K8s admission controllers 

### Implementation
A sample implementation follows using these pipeline components:

* Github Actions (build, publish container images)
* Github Container Registry (GCR, container registry)
* Github Runners (build agents)
* Anchore Syft (Software Bill of Materials SBOM) as pipeline stage
* Sigstore Cosign (attach SBOM and sign container image)
* Anchore Grype (CVE scan engine using image layer inspection or SBOM data)